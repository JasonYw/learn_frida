1.需要的基础知识
安卓底层 linux 内核 需要有些Linux命令行
smail代码 反编译后是smail代码
java 核心代码
JNI 通过jni，java才可以调用c
c/c++ so文件 反编译难度较大
arm汇编（后期很重要）
android 提供的api

2.apk的基本结构
apk 其实是zip的压缩包
assets 资源目录 是没有编译过的 可以直接拿来用的 以及可以有任意深度的子目录
lib 本地代码 一般是so文件
libs 第三方jar包
META-INF apk的签名 每个apk都有，正常的android系统会验证，保证文件的完整性以及不会被篡改
res 资源 编译之后的 不能直接用 里面是xml，图标 布局 apktool进行反编译
AndroidManifest 清单文件 需要反编译 包含 系统权限 包名 是否支持调试
resources.arsc 编译之后的 资源索引表
dex文件 反编译之后 smail  代码 再把smail代码转换成java代码，有多个dex是因为文件大小限制，我们反编译完应该是只有一个samil文件


3.apk打包流程

4.apk安装
1.拷贝akp文件放入/data/app/包名
2.用资源管理器解析apk中的资源文件
3.解析AndroidManifest.xml 并会在/data/data 创建一些数据
4.对我们dex文件进行优化 保存在/data/dalvik-cache
5.解析AndroidManifest.xml四大组件信息注册发送广播


3.jvm Dvm Art虚拟机
jvm 运行.class文件
5.0之前dalvik虚拟机只会执行.dex文件，dx工具会把.class文件打包成.dex文件
5.0之后art虚拟机，在安装时直接将.dex文件转化成可执行文件.oat文件，并且art支持多dex所以不存在合包的问题，所以art虚拟机会很大提升app冷启动速度
xposed hook的是java代码所以xposed不支持5.0以上的系统

4.逆向工具
androidkiller
jadx


arm分析和动态调试不一致时，可能是so里面的有多个cpu版本
签名机制 会和源码去校验是否你的apk文件有动过，所以改了源码后才放回apk在安装是无法安装好的
可以使用信誉破解器，这样不需要重新签名也可以安装
重签：把apk重新签名


xposed依然是老大，xposed是java代码写hook
frida有可能无法注入 so层可以防止其注入
frida推荐真机 8.1 Pixel


overloads 重载 
return this.fangfa.apply(this,argumensts)

hook 构造方法
类.$init.implementation = function(){
    this.$init()
}
类.$init.overload.implementation = function(){
    this.$init()
}
对象实例化
var a  = java.use("OBJECT")
a.$new("参数") //实例化


修改类的字段
修改类的静态字段
var a = java.use("OBJECT")
a.类的静态变量名.value = '更改静态变量的值,其实就多了一个value'

修改类的非静态类的变量名
//注意非静态变量名 不能与函数名相同
java.choose("类名",{
    onMatch: function(obj){
        obj.类的非静态变量名.value = '更非改静态变量的值,其实就多了一个value'
        obj._类的非静态变量名与函数名相同.value = '类的非静态变量名与函数名相同需在前面加下滑线'
    },
    onComplete: function(){},
});


内部类
内部类：类包着类
class a{public class b {}}
var obj = java.use("a$b")

匿名类
class a {
    new obj() {
        public void get() {}
    }
}
var obj = java.use("a$1")
obj.get.implementation


枚举所有类

动态加载dex(加壳)
hook出来发现了加载了类，但是jadx里没有，说明动态加载了
java层可以动态加载dex，dexclassloader，也可以在so层动态加载
dex也可以加密，java层加载后，如果dex有加密 需要解密之后再用
hook脚本：无法按照正常hook那样去写
如果 dongtaiclass  动态加载的话
异步：
    java.enumerateClassLoaders({
        onMatch:function(loader){
            try:
                if(loader.findclass("dongtaiclass")){
                    Java.classFactory.loader = loader 
                    var dynamic = Java.use("dongtaiclass")
                    console.log(dynamic)
                    dynamic.func.implementation ...
                }
            catch:
                pass
        }
        onComplete:function(){}
    })


特殊类型的遍历与修改
主动调用
静态
    function hooktest11(){
        Java.perform(function(){
            var b = Java.use("java.lang.String")
            var a = Java.use("dongtai.lei")
            b.$new("xiaojianbang") #获取的是 java中的字符串对象 实例化
            var res = a.encrypt(b.getBytes())  因为java string有getBytes方法
            return res
        })
    }

非静态方法主动调用 // 需要实例化对象 1
var obj = java.use("a.b").$new("ry",3000000); 
obj.getinfo()

//2 //不需要实例化了，因为是 在onmatch里 所以已经有示例了 obj就是示例 会调用内存中全部这个类的对象，所以实例存在多个 可能调用多次
java.choose("a.b",{
    onMatch:function(obj){
        var str = obj.getinfo()
    },
    onComplete:function(){
    },
});

//打印堆栈 谁调用了谁的关系
console.log(java.use("android.util.Log").getStackTraceString(Java.use("Java.lang.exception").$new()))



//加载dex
java.openClassFile("接收安卓端dex的路径").load();
java.use(dex的package.类)
sdx build-tools 中 有个 dx.bat 可以打包jar包 
.... 






